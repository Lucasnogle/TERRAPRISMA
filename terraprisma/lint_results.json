[{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\app.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\config.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\controllers\\jobController.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\controllers\\planController.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\controllers\\tenantController.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'validateUpdatePreferences' is assigned a value but never used.","line":3,"column":9,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":34}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const asyncHandler = require('../middlewares/asyncHandler');\r\nconst tenantService = require('../services/tenantService');\r\nconst { validateUpdatePreferences } = require('../validators/tenantValidator');\r\n\r\n/**\r\n * GET /api/tenant - Retorna dados do tenant atual\r\n */\r\nconst getTenant = asyncHandler(async (req, res) => {\r\n    const tenant = await tenantService.getTenant(req.tenant.id);\r\n\r\n    res.json({\r\n        ok: true,\r\n        data: tenant,\r\n    });\r\n});\r\n\r\nmodule.exports = {\r\n    getTenant,\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\cron.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'crypto' is assigned a value but never used.","line":3,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":3,"endColumn":13}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"require('dotenv').config();\r\nconst cron = require('node-cron');\r\nconst crypto = require('crypto');\r\nconst { initializeFirebase } = require('./modules/connectionFirestore');\r\nconst { updateHeartbeat } = require('./services/firestoreService');\r\nconst jobService = require('./services/jobService');\r\nconst config = require('./config');\r\nconst { loggers } = require('./utils/logger');\r\n\r\n// Inicializa Firebase para o cron\r\ninitializeFirebase();\r\n\r\n// ============================================\r\n// Heartbeat - a cada 5 minutos\r\n// ============================================\r\ncron.schedule('*/5 * * * *', async () => {\r\n    try {\r\n        await updateHeartbeat();\r\n        loggers.cron.debug('Heartbeat updated');\r\n    } catch (error) {\r\n        loggers.cron.error('Heartbeat error', { error: error.message });\r\n    }\r\n}, {\r\n    scheduled: true,\r\n    timezone: config.timezone\r\n});\r\n\r\n// ============================================\r\n// Recuperação de Jobs Travados - a cada 5 minutos\r\n// ============================================\r\ncron.schedule('*/5 * * * *', async () => {\r\n    loggers.cron.debug('Checking for stuck jobs...');\r\n\r\n    try {\r\n        const result = await jobService.recoverStuckJobs();\r\n\r\n        if (result.recovered > 0 || result.movedToFinal > 0) {\r\n            loggers.cron.info('Stuck jobs processed', { recovered: result.recovered, dlq: result.movedToFinal });\r\n        }\r\n    } catch (error) {\r\n        loggers.cron.error('Error recovering stuck jobs', { error: error.message });\r\n    }\r\n}, {\r\n    scheduled: true,\r\n    timezone: config.timezone\r\n});\r\n\r\n// ============================================\r\n// Startup Log\r\n// ============================================\r\nloggers.cron.info(`Cron jobs started (timezone: ${config.timezone})`);\r\nloggers.cron.info('Schedules loaded: Heartbeat (5m), Stuck Recovery (5m)');\r\nloggers.cron.info('Job settings', { maxAttempts: config.job.maxAttempts, timeout: config.job.runningTimeoutMinutes });\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\middlewares\\apiKey.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\middlewares\\asyncHandler.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\middlewares\\auth.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\middlewares\\errorHandler.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'next' is defined but never used.","line":7,"column":38,"nodeType":"Identifier","messageId":"unusedVar","endLine":7,"endColumn":42}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const { ZodError } = require('zod');\r\n\r\n/**\r\n * Middleware centralizado de tratamento de erros\r\n * Deve ser o último middleware no app.js\r\n */\r\nconst errorHandler = (err, req, res, next) => {\r\n    // Log do erro (sem expor secrets)\r\n    console.error(`[API] Error:`, {\r\n        message: err.message,\r\n        path: req.path,\r\n        method: req.method,\r\n        stack: process.env.NODE_ENV !== 'production' ? err.stack : undefined,\r\n    });\r\n\r\n    // Erro de validação Zod\r\n    if (err instanceof ZodError) {\r\n        return res.status(400).json({\r\n            ok: false,\r\n            error: {\r\n                code: 'VALIDATION_ERROR',\r\n                message: 'Dados inválidos',\r\n                details: err.errors.map(e => ({\r\n                    field: e.path.join('.'),\r\n                    message: e.message,\r\n                })),\r\n            },\r\n        });\r\n    }\r\n\r\n    // Erro customizado com statusCode\r\n    if (err.statusCode) {\r\n        return res.status(err.statusCode).json({\r\n            ok: false,\r\n            error: {\r\n                code: err.code || 'ERROR',\r\n                message: err.message,\r\n            },\r\n        });\r\n    }\r\n\r\n    // Erro do Firestore\r\n    if (err.code && typeof err.code === 'number') {\r\n        const firestoreErrors = {\r\n            3: { status: 400, code: 'INVALID_ARGUMENT' },\r\n            5: { status: 404, code: 'NOT_FOUND' },\r\n            6: { status: 409, code: 'ALREADY_EXISTS' },\r\n            7: { status: 403, code: 'PERMISSION_DENIED' },\r\n            16: { status: 401, code: 'UNAUTHENTICATED' },\r\n        };\r\n\r\n        const mapped = firestoreErrors[err.code];\r\n        if (mapped) {\r\n            return res.status(mapped.status).json({\r\n                ok: false,\r\n                error: {\r\n                    code: mapped.code,\r\n                    message: err.message || 'Firestore error',\r\n                },\r\n            });\r\n        }\r\n    }\r\n\r\n    // Erro genérico\r\n    res.status(500).json({\r\n        ok: false,\r\n        error: {\r\n            code: 'INTERNAL_ERROR',\r\n            message: process.env.NODE_ENV === 'production'\r\n                ? 'Erro interno do servidor'\r\n                : err.message,\r\n        },\r\n    });\r\n};\r\n\r\n/**\r\n * Cria um erro customizado com statusCode\r\n */\r\nconst createError = (statusCode, code, message) => {\r\n    const err = new Error(message);\r\n    err.statusCode = statusCode;\r\n    err.code = code;\r\n    return err;\r\n};\r\n\r\nmodule.exports = { errorHandler, createError };\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\middlewares\\rateLimit.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\modules\\connectionFirestore.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\modules\\connectionMongoDB.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\modules\\connectionMySQL.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\modules\\connectionSqlServer.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\router.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\server.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\services\\aiService.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'weekStart' is defined but never used.","line":27,"column":43,"nodeType":"Identifier","messageId":"unusedVar","endLine":27,"endColumn":52}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const config = require('../config');\r\nconst { loggers } = require('../utils/logger');\r\n\r\n/**\r\n * Gera prioridades semanais usando IA\r\n * \r\n * TODO: Integrar com OpenAI quando OPENAI_API_KEY estiver configurada\r\n * Por enquanto, usa gerador determinístico baseado no contexto\r\n * \r\n * @param {{ context?: string, weekStart: string }} input\r\n * @returns {Promise<Array<{ title: string, category: string, reasoning: string }>>}\r\n */\r\nconst generatePriorities = async ({ context = '', weekStart }) => {\r\n    // Se OpenAI estiver configurada, usar\r\n    if (config.openai?.apiKey) {\r\n        return generateWithOpenAI({ context, weekStart });\r\n    }\r\n\r\n    // Fallback: gerador determinístico\r\n    return generateDeterministic({ context, weekStart });\r\n};\r\n\r\n/**\r\n * Gerador determinístico (stub)\r\n * Analisa palavras-chave no contexto para criar prioridades relevantes\r\n */\r\nconst generateDeterministic = ({ context, weekStart }) => {\r\n    const priorities = [];\r\n    const contextLower = (context || '').toLowerCase();\r\n\r\n    // Prioridade 1: baseada em palavras-chave\r\n    if (contextLower.includes('reunião') || contextLower.includes('meeting')) {\r\n        priorities.push({\r\n            title: 'Preparar para reuniões da semana',\r\n            category: 'trabalho',\r\n            reasoning: 'Identificado que você tem reuniões. Preparação reduz ansiedade.',\r\n        });\r\n    } else if (contextLower.includes('entrega') || contextLower.includes('prazo') || contextLower.includes('deadline')) {\r\n        priorities.push({\r\n            title: 'Focar na entrega principal',\r\n            category: 'trabalho',\r\n            reasoning: 'Prazo identificado. Concentrar energia no que gera impacto.',\r\n        });\r\n    } else {\r\n        priorities.push({\r\n            title: 'Definir a tarefa mais importante da semana',\r\n            category: 'planejamento',\r\n            reasoning: 'Clareza sobre o que importa reduz ansiedade de domingo.',\r\n        });\r\n    }\r\n\r\n    // Prioridade 2: organização\r\n    if (contextLower.includes('caos') || contextLower.includes('bagunça') || contextLower.includes('organizar')) {\r\n        priorities.push({\r\n            title: 'Organizar ambiente de trabalho',\r\n            category: 'organização',\r\n            reasoning: 'Ambiente organizado melhora foco e produtividade.',\r\n        });\r\n    } else {\r\n        priorities.push({\r\n            title: 'Revisar agenda e bloquear tempo para foco',\r\n            category: 'planejamento',\r\n            reasoning: 'Proteger tempo evita ser consumido por urgências alheias.',\r\n        });\r\n    }\r\n\r\n    // Prioridade 3: vida pessoal\r\n    if (contextLower.includes('saúde') || contextLower.includes('exercício') || contextLower.includes('academia')) {\r\n        priorities.push({\r\n            title: 'Manter compromisso com saúde física',\r\n            category: 'vida_pessoal',\r\n            reasoning: 'Sua energia física impacta tudo mais. Não negligencie.',\r\n        });\r\n    } else {\r\n        priorities.push({\r\n            title: 'Uma atividade pessoal que recarrega',\r\n            category: 'vida_pessoal',\r\n            reasoning: 'Evitar terminar a semana zerado fora do trabalho.',\r\n        });\r\n    }\r\n\r\n    return priorities;\r\n};\r\n\r\n/**\r\n * Gerador usando OpenAI\r\n * TODO: Implementar quando configurado\r\n */\r\nconst generateWithOpenAI = async ({ context, weekStart }) => {\r\n    // TODO: Implementar chamada para OpenAI\r\n    // const { Configuration, OpenAIApi } = require('openai');\r\n    // const configuration = new Configuration({ apiKey: config.openai.apiKey });\r\n    // const openai = new OpenAIApi(configuration);\r\n\r\n    // TODO(SEGUNDA-LEVE): Implement OpenAI call when API key is configured\r\n    loggers.ai.info('OpenAI configured but not implemented. Using deterministic fallback.');\r\n    return generateDeterministic({ context, weekStart });\r\n};\r\n\r\nmodule.exports = {\r\n    generatePriorities,\r\n    generateDeterministic,\r\n    generateWithOpenAI,\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\services\\emailService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\services\\firestoreService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\services\\jobService.js","messages":[{"ruleId":"no-prototype-builtins","severity":2,"message":"Do not access Object.prototype method 'hasOwnProperty' from target object.","line":358,"column":20,"nodeType":"CallExpression","messageId":"prototypeBuildIn","endLine":358,"endColumn":34,"suggestions":[{"messageId":"callObjectPrototype","data":{"prop":"hasOwnProperty"},"fix":{"range":[10818,10840],"text":"Object.prototype.hasOwnProperty.call(counts, "},"desc":"Call Object.prototype.hasOwnProperty explicitly."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"const admin = require('firebase-admin');\r\nconst { getFirestore } = require('../modules/connectionFirestore');\r\nconst config = require('../config');\r\nconst { loggers } = require('../utils/logger');\r\n\r\n// Status finais (Dead Letter Queue)\r\nconst FINAL_STATUSES = ['success', 'cancelled', 'error_final'];\r\nconst RETRYABLE_STATUSES = ['error']; // Apenas 'error' pode ser retried\r\n\r\n/**\r\n * Cria um novo job na fila\r\n * @param {{ type: string, payload: object, tenantId?: string }} data\r\n * @returns {Promise<{ id: string, ...job }>}\r\n */\r\nconst createJob = async ({ type, payload = {}, tenantId = null }) => {\r\n    const db = getFirestore();\r\n    const now = admin.firestore.FieldValue.serverTimestamp();\r\n\r\n    const jobData = {\r\n        type,\r\n        status: 'queued',\r\n        payload,\r\n        tenantId, // Multi-tenant support\r\n        result: null,\r\n        error: null,\r\n        createdAt: now,\r\n        updatedAt: now,\r\n        lockedAt: null,\r\n        attempts: 0,\r\n    };\r\n\r\n    const docRef = await db.collection('jobs').add(jobData);\r\n\r\n    // TODO(SEGUNDA-LEVE): Add correlation ID for job tracing\r\n    loggers.api.info(`Job created: ${docRef.id}`, { type, tenantId: tenantId || 'system' });\r\n\r\n    return {\r\n        id: docRef.id,\r\n        ...jobData,\r\n        createdAt: new Date().toISOString(),\r\n        updatedAt: new Date().toISOString(),\r\n    };\r\n};\r\n\r\n/**\r\n * Lista jobs ordenados por createdAt desc\r\n * @param {{ limit?: number, status?: string, tenantId?: string }} options\r\n * @returns {Promise<object[]>}\r\n */\r\nconst listJobs = async ({ limit = 20, status = null, tenantId = null } = {}) => {\r\n    const db = getFirestore();\r\n    let query = db.collection('jobs');\r\n\r\n    // Filtro por tenant (se especificado)\r\n    if (tenantId) {\r\n        query = query.where('tenantId', '==', tenantId);\r\n    }\r\n\r\n    // Ordenação (sem orderBy se tiver where para evitar índice)\r\n    // Para produção: criar índice composto\r\n    const snapshot = await query.limit(limit).get();\r\n\r\n    let jobs = snapshot.docs.map(doc => ({\r\n        id: doc.id,\r\n        ...doc.data(),\r\n        createdAt: doc.data().createdAt?.toDate?.()?.toISOString() || null,\r\n        updatedAt: doc.data().updatedAt?.toDate?.()?.toISOString() || null,\r\n        lockedAt: doc.data().lockedAt?.toDate?.()?.toISOString() || null,\r\n    }));\r\n\r\n    // Ordenar em memória (workaround para evitar índice)\r\n    jobs.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));\r\n\r\n    if (status) {\r\n        jobs = jobs.filter(j => j.status === status);\r\n    }\r\n\r\n    return jobs.slice(0, limit);\r\n};\r\n\r\n/**\r\n * Busca um job pelo ID\r\n * @param {string} id\r\n * @param {string|null} tenantId - Se fornecido, valida pertencimento\r\n * @returns {Promise<object|null>}\r\n */\r\nconst getJob = async (id, tenantId = null) => {\r\n    const db = getFirestore();\r\n    const doc = await db.collection('jobs').doc(id).get();\r\n\r\n    if (!doc.exists) return null;\r\n\r\n    const data = doc.data();\r\n\r\n    // Validação de tenant se especificado\r\n    if (tenantId && data.tenantId !== tenantId) {\r\n        return null;\r\n    }\r\n\r\n    return {\r\n        id: doc.id,\r\n        ...data,\r\n        createdAt: data.createdAt?.toDate?.()?.toISOString() || null,\r\n        updatedAt: data.updatedAt?.toDate?.()?.toISOString() || null,\r\n        lockedAt: data.lockedAt?.toDate?.()?.toISOString() || null,\r\n    };\r\n};\r\n\r\n/**\r\n * Retry de um job com erro (não permite retry de error_final)\r\n * @param {string} id\r\n * @param {string|null} tenantId\r\n * @returns {Promise<{ success: boolean, message?: string }>}\r\n */\r\nconst retryJob = async (id, tenantId = null) => {\r\n    const db = getFirestore();\r\n    const docRef = db.collection('jobs').doc(id);\r\n    const doc = await docRef.get();\r\n\r\n    if (!doc.exists) {\r\n        return { success: false, message: 'job not found' };\r\n    }\r\n\r\n    const data = doc.data();\r\n\r\n    // Validação de tenant\r\n    if (tenantId && data.tenantId !== tenantId) {\r\n        return { success: false, message: 'job not found' };\r\n    }\r\n\r\n    // Apenas status 'error' pode ser retried (não error_final)\r\n    if (!RETRYABLE_STATUSES.includes(data.status)) {\r\n        return { success: false, message: `only ${RETRYABLE_STATUSES.join(', ')} jobs can be retried` };\r\n    }\r\n\r\n    await docRef.update({\r\n        status: 'queued',\r\n        result: null,\r\n        error: null,\r\n        lockedAt: null,\r\n        updatedAt: admin.firestore.FieldValue.serverTimestamp(),\r\n        attempts: admin.firestore.FieldValue.increment(1),\r\n    });\r\n\r\n    return { success: true };\r\n};\r\n\r\n/**\r\n * Cancela um job queued ou running\r\n * @param {string} id\r\n * @param {string|null} tenantId\r\n * @returns {Promise<{ success: boolean, message?: string }>}\r\n */\r\nconst cancelJob = async (id, tenantId = null) => {\r\n    const db = getFirestore();\r\n    const docRef = db.collection('jobs').doc(id);\r\n    const doc = await docRef.get();\r\n\r\n    if (!doc.exists) {\r\n        return { success: false, message: 'job not found' };\r\n    }\r\n\r\n    const data = doc.data();\r\n\r\n    // Validação de tenant\r\n    if (tenantId && data.tenantId !== tenantId) {\r\n        return { success: false, message: 'job not found' };\r\n    }\r\n\r\n    if (!['queued', 'running'].includes(data.status)) {\r\n        return { success: false, message: 'only queued or running jobs can be cancelled' };\r\n    }\r\n\r\n    await docRef.update({\r\n        status: 'cancelled',\r\n        updatedAt: admin.firestore.FieldValue.serverTimestamp(),\r\n    });\r\n\r\n    return { success: true };\r\n};\r\n\r\n/**\r\n * Claim do próximo job queued (com transaction para lock)\r\n * Nota: Não usa orderBy para evitar necessidade de índice composto\r\n * @returns {Promise<object|null>}\r\n */\r\nconst claimNextJob = async () => {\r\n    const db = getFirestore();\r\n\r\n    // Busca jobs queued (sem orderBy para evitar índice)\r\n    const snapshot = await db.collection('jobs')\r\n        .where('status', '==', 'queued')\r\n        .limit(1)\r\n        .get();\r\n\r\n    if (snapshot.empty) return null;\r\n\r\n    const jobDoc = snapshot.docs[0];\r\n    const jobRef = db.collection('jobs').doc(jobDoc.id);\r\n\r\n    // Transaction para garantir lock atômico\r\n    try {\r\n        const result = await db.runTransaction(async (transaction) => {\r\n            const freshDoc = await transaction.get(jobRef);\r\n\r\n            if (!freshDoc.exists) return null;\r\n\r\n            const data = freshDoc.data();\r\n\r\n            // Revalidar que ainda está queued\r\n            if (data.status !== 'queued') return null;\r\n\r\n            // Lock do job\r\n            transaction.update(jobRef, {\r\n                status: 'running',\r\n                lockedAt: admin.firestore.FieldValue.serverTimestamp(),\r\n                updatedAt: admin.firestore.FieldValue.serverTimestamp(),\r\n                attempts: admin.firestore.FieldValue.increment(1),\r\n            });\r\n\r\n            return {\r\n                id: freshDoc.id,\r\n                ...data,\r\n            };\r\n        });\r\n\r\n        return result;\r\n    } catch (error) {\r\n        console.error('[WORKER] Erro no claimNextJob:', error.message);\r\n        return null;\r\n    }\r\n};\r\n\r\n/**\r\n * Atualiza um job com sucesso\r\n * @param {string} id\r\n * @param {object} result\r\n */\r\nconst completeJob = async (id, result) => {\r\n    const db = getFirestore();\r\n    await db.collection('jobs').doc(id).update({\r\n        status: 'success',\r\n        result,\r\n        updatedAt: admin.firestore.FieldValue.serverTimestamp(),\r\n    });\r\n};\r\n\r\n/**\r\n * Atualiza um job com erro\r\n * @param {string} id\r\n * @param {{ message: string, stack?: string, code?: string }} error\r\n */\r\nconst failJob = async (id, error) => {\r\n    const db = getFirestore();\r\n    await db.collection('jobs').doc(id).update({\r\n        status: 'error',\r\n        error: {\r\n            code: error.code || 'PROCESSING_ERROR',\r\n            message: error.message || String(error),\r\n            stack: error.stack || null,\r\n        },\r\n        updatedAt: admin.firestore.FieldValue.serverTimestamp(),\r\n    });\r\n};\r\n\r\n/**\r\n * Marca um job como error_final (Dead Letter Queue)\r\n * @param {string} id\r\n * @param {string} reason\r\n */\r\nconst markJobFinal = async (id, reason) => {\r\n    const db = getFirestore();\r\n    await db.collection('jobs').doc(id).update({\r\n        status: 'error_final',\r\n        error: {\r\n            code: 'MAX_ATTEMPTS_EXCEEDED',\r\n            message: reason,\r\n        },\r\n        updatedAt: admin.firestore.FieldValue.serverTimestamp(),\r\n    });\r\n};\r\n\r\n/**\r\n * Recupera jobs travados (running por muito tempo)\r\n * @returns {Promise<{ recovered: number, movedToFinal: number }>}\r\n */\r\nconst recoverStuckJobs = async () => {\r\n    const db = getFirestore();\r\n    const timeoutMinutes = config.job.runningTimeoutMinutes || 10;\r\n    const maxAttempts = config.job.maxAttempts || 3;\r\n    const cutoffTime = new Date(Date.now() - timeoutMinutes * 60 * 1000);\r\n\r\n    const snapshot = await db.collection('jobs')\r\n        .where('status', '==', 'running')\r\n        .get();\r\n\r\n    let recovered = 0;\r\n    let movedToFinal = 0;\r\n\r\n    for (const doc of snapshot.docs) {\r\n        const data = doc.data();\r\n        const lockedAt = data.lockedAt?.toDate?.();\r\n\r\n        // Verificar se está travado há mais tempo que o timeout\r\n        if (lockedAt && lockedAt < cutoffTime) {\r\n            if ((data.attempts || 0) >= maxAttempts) {\r\n                // Mover para Dead Letter Queue\r\n                await markJobFinal(doc.id, `Job stuck after ${maxAttempts} attempts. Timeout: ${timeoutMinutes}min`);\r\n                movedToFinal++;\r\n                loggers.cron.warn(`Job moved to DLQ: ${doc.id}`, { attempts: data.attempts });\r\n            } else {\r\n                // Recuperar para queued\r\n                await db.collection('jobs').doc(doc.id).update({\r\n                    status: 'queued',\r\n                    lockedAt: null,\r\n                    updatedAt: admin.firestore.FieldValue.serverTimestamp(),\r\n                });\r\n                recovered++;\r\n                loggers.cron.info(`Job recovered: ${doc.id}`, { attempts: data.attempts });\r\n            }\r\n        }\r\n    }\r\n\r\n    return { recovered, movedToFinal };\r\n};\r\n\r\n/**\r\n * Obtém métricas de jobs\r\n * @returns {Promise<object>}\r\n */\r\nconst getJobMetrics = async () => {\r\n    const db = getFirestore();\r\n    const now = new Date();\r\n    const last24h = new Date(now.getTime() - 24 * 60 * 60 * 1000);\r\n\r\n    // Contagens por status (todos os tempos)\r\n    const allJobs = await db.collection('jobs').get();\r\n\r\n    const counts = {\r\n        queued: 0,\r\n        running: 0,\r\n        success: 0,\r\n        error: 0,\r\n        error_final: 0,\r\n        cancelled: 0,\r\n    };\r\n\r\n    const last24hCounts = {\r\n        success: 0,\r\n        error: 0,\r\n        error_final: 0,\r\n    };\r\n\r\n    for (const doc of allJobs.docs) {\r\n        const data = doc.data();\r\n        const status = data.status || 'unknown';\r\n\r\n        if (counts.hasOwnProperty(status)) {\r\n            counts[status]++;\r\n        }\r\n\r\n        // Últimas 24h (baseado em updatedAt)\r\n        const updatedAt = data.updatedAt?.toDate?.();\r\n        if (updatedAt && updatedAt > last24h) {\r\n            if (status === 'success') last24hCounts.success++;\r\n            if (status === 'error') last24hCounts.error++;\r\n            if (status === 'error_final') last24hCounts.error_final++;\r\n        }\r\n    }\r\n\r\n    return {\r\n        total: allJobs.size,\r\n        byStatus: counts,\r\n        last24h: last24hCounts,\r\n        timestamp: now.toISOString(),\r\n    };\r\n};\r\n\r\nmodule.exports = {\r\n    createJob,\r\n    listJobs,\r\n    getJob,\r\n    retryJob,\r\n    cancelJob,\r\n    claimNextJob,\r\n    completeJob,\r\n    failJob,\r\n    markJobFinal,\r\n    recoverStuckJobs,\r\n    getJobMetrics,\r\n    FINAL_STATUSES,\r\n    RETRYABLE_STATUSES,\r\n};\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\services\\planService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\services\\tenantService.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\utils\\logger.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\validators\\jobValidator.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\validators\\planValidator.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\validators\\tenantValidator.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]},{"filePath":"C:\\Sites\\TERRAPRISMA\\terraprisma\\src\\worker.js","messages":[{"ruleId":"no-unused-vars","severity":1,"message":"'tenantService' is assigned a value but never used.","line":9,"column":7,"nodeType":"Identifier","messageId":"unusedVar","endLine":9,"endColumn":20}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * TERRAPRISMA Worker\r\n * Processa jobs da fila do Firestore\r\n */\r\n\r\nrequire('dotenv').config();\r\nconst { initializeFirebase } = require('./modules/connectionFirestore');\r\nconst jobService = require('./services/jobService');\r\nconst tenantService = require('./services/tenantService');\r\nconst { loggers } = require('./utils/logger');\r\n\r\n// Intervalo de polling (ms)\r\nconst POLL_INTERVAL = 2000;\r\n\r\n// Flag para graceful shutdown\r\nlet isRunning = true;\r\n\r\n/**\r\n * Simula processamento (sleep)\r\n */\r\nconst sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));\r\n\r\n// ============================================\r\n// Job Handlers\r\n// ============================================\r\n\r\n/**\r\n * Handler: test\r\n * Job de teste básico\r\n */\r\nconst handleTest = async (job) => {\r\n    await sleep(500);\r\n    return { ok: true, echo: job.payload, processedAt: new Date().toISOString() };\r\n};\r\n\r\n// ============================================\r\n// Dispatcher\r\n// ============================================\r\n\r\n/**\r\n * Processa um job baseado no type\r\n */\r\nconst processJob = async (job) => {\r\n    loggers.worker.info(`Processing job ${job.id}`, { type: job.type });\r\n\r\n    switch (job.type) {\r\n        case 'test':\r\n            return handleTest(job);\r\n\r\n        default:\r\n            throw new Error(`Unknown job type: ${job.type}`);\r\n    }\r\n};\r\n\r\n// ============================================\r\n// Main Loop\r\n// ============================================\r\n\r\n/**\r\n * Loop principal do worker\r\n */\r\nconst runWorker = async () => {\r\n    loggers.worker.info('Worker starting...');\r\n\r\n    // Inicializa Firebase\r\n    try {\r\n        initializeFirebase();\r\n    } catch (error) {\r\n        loggers.worker.error('Failed to initialize Firebase', { error: error.message });\r\n        process.exit(1);\r\n    }\r\n\r\n    loggers.worker.info('Waiting for jobs...');\r\n\r\n    while (isRunning) {\r\n        try {\r\n            // Tenta pegar o próximo job\r\n            const job = await jobService.claimNextJob();\r\n\r\n            if (!job) {\r\n                // Sem jobs, aguarda antes de tentar novamente\r\n                await sleep(POLL_INTERVAL);\r\n                continue;\r\n            }\r\n\r\n            console.log(`[WORKER] Job claimed: ${job.id}`);\r\n\r\n            try {\r\n                // Processa o job\r\n                const result = await processJob(job);\r\n\r\n                // Marca como sucesso\r\n                await jobService.completeJob(job.id, result);\r\n                loggers.worker.info(`Job completed: ${job.id}`);\r\n            } catch (processError) {\r\n                // Marca como erro\r\n                await jobService.failJob(job.id, processError);\r\n                loggers.worker.error(`Job failed: ${job.id}`, { error: processError.message });\r\n            }\r\n        } catch (error) {\r\n            loggers.worker.error('Loop error', { error: error.message });\r\n            await sleep(POLL_INTERVAL);\r\n        }\r\n    }\r\n\r\n    loggers.worker.info('Worker stopped.');\r\n};\r\n\r\n// Graceful shutdown\r\nprocess.on('SIGINT', () => {\r\n    loggers.worker.info('SIGINT received, shutting down...');\r\n    isRunning = false;\r\n});\r\n\r\nprocess.on('SIGTERM', () => {\r\n    loggers.worker.info('SIGTERM received, shutting down...');\r\n    isRunning = false;\r\n});\r\n\r\n// Inicia o worker\r\nrunWorker().catch(err => {\r\n    loggers.worker.error('Fatal error', { error: err.message });\r\n    process.exit(1);\r\n});\r\n","usedDeprecatedRules":[{"ruleId":"no-extra-semi","replacedBy":[]},{"ruleId":"no-mixed-spaces-and-tabs","replacedBy":[]}]}]